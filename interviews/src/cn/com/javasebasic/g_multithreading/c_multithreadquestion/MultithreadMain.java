package cn.com.javasebasic.g_multithreading.c_multithreadquestion;

public class MultithreadMain {

    /**
     *
     *
     */

    public static void main(String[] args) {

        // 1. 多线程的创建方式
        /**
         *  （1）、继承Thread类：
         *      但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，并且，
         *      启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线
         *      程，并执行run()方法。这种方式实现多线程很简单，通过自己的类直接extend Thread，并复写run()方法，就可以
         *      启动新线程并执行自己定义的run()方法。例如：继承Thread类实现多线程，并在合适的地方启动线程.
         *  （2）、实现Runnable接口的方式实现多线程，并且实例化Thread，传入自己的Thread实例，调用run( )方法
         *  （3）、使用ExecutorService、Callable、Future实现有返回结果的多线程：ExecutorService、Callable、Future
         *      这个对象实际上都是属于Executor框架中的功能类。返回结果的线程是在JDK1.5中引入
         *      的新特征，确实很实用，有了这种特征我就不需要再为了得到返回值而大费周折了，而且即便实现了也可能漏洞百出。
         *      可返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行Callable任务后，可以
         *      获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口
         *      ExecutorService就可以实现传说中有返回结果的多线程了。
         *
         */

        // 2. 在java 中 wait 和 sleep 方法的不同？
        /**
         *      最大的不同是wait 会释放锁，而 sleep 一直持有锁。 wait 通常被用于线程间的交互，sleep 通常被用于暂停执行
         */

        // 3. synchronized和volatile关键字的作用
        /**
         *      一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
         *      1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
         *      2）禁止进行指令重排序。
         *          volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
         *          synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
         *          1. volatile仅能使用在变量级别；
         *             synchronized则可以使用在变量、方法、和类级别的
         *          2. volatile仅能实现变量的修改可见性，并不能保证原子性；
         *             synchronized则可以保证变量的修改可见性和原子性
         *          3. volatile不会造成线程的阻塞；
         *             synchronized可能会造成线程的阻塞。
         *          4. volatile标记的变量不会被编译器优化；
         *             synchronized标记的变量可以被编译器优化
         *
         *
         */


         // 4. 分析线程并发访问代码解释原因

         // 5. 什么是线程池，如何使用？
         /**
          *     线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用new线程而是直接去池中拿线程即可，节
          *     省了开辟子线程的时间，提高的代码执行效率。
          *     在JDK的java.util.concurrent.Executors中提供了生成多种线程池的静态方法。
          *     然后调用他们的execute方法即可。
          */

         // 6. 常用的线程池有哪些？
        /**
         *    newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
         *    newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
         *    newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统
         *                          （或者说JVM）能够创建的最大线程大小。
         *    newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。
         *    newSingleThreadScheduledExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。
         */

        // 7. 请叙述一下您对线程池的理解？
        /**
         *   （如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）
         *   合理利用线程池能够带来三个好处。
         *      第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
         *      第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
         *      第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，
         *          使用线程池可以进行统一的分配，调优和监控。
         */

        // 8. 线程池的启动策略？
        /**
         *  1、线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。
         *  2、当调用execute() 方法添加一个任务时，线程池会做如下判断：
         *      a. 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
         *      b. 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列。
         *      c. 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建线程运行这个任务；
         *      d. 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常，告诉调用者
         *          “我不能再接受任务了”。
         *  3、当一个线程完成任务时，它会从队列中取下一个任务来执行。
         *  4、当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于
         *      corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。
         *
         */

        //9. 如何控制某个方法允许并发访问线程的个数？
        /**
         *  可以使用Semaphore控制，第16行的构造函数创建了一个Semaphore对象，并且初始化了5个信号。这样的
         *  效果是控件test方法最多只能有5个线程并发访问，对于5个线程时就排队等待，走一个来一下。第33行，请求一
         *  个信号（消费一个信号），如果信号被用完了则等待，第45行释放一个信号，释放的信号新的线程就可以使用了。
         */


        // 10. 三个线程a、b、c并发运行，b,c需要a线程的数据怎么实现
        /**
         *  定义一个信号量，该类内部维持了多个线程锁，可以阻塞多个线程，释放多个线程，
         *  线程的阻塞和释放是通过permit概念来实现的
         *  线程通过semaphore.acquire()方法获取permit，如果当前semaphore有permit则分配给该线程，
         *   如果没有则阻塞该线程直到semaphore
         *    调用release（）方法释放permit
         *    构造函数中参数：permit（允许） 个数，
         */


        // 11. 同一个类中的2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗？


        // 12. 什么情况下导致线程死锁，遇到线程死锁该怎么解决？
        /**
         *   1. 死锁的定义：所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。
         *   2. 死锁产生的必要条件：
         *      互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个线程所占有。
         *              此时若有其他线程请求该资源，则请求线程只能等待。
         *      不剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放
         *              （只能是主动释放)。
         *      请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求进程被阻塞，
         *              但对自己已获得的资源保持不放。
         *      循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求。即存在一个处于
         *              等待状态的线程集合{Pl, P2, ..., pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, ..., n-1)，
         *              Pn等待的资源被P0占有.
         *
         *
         */

        // 13. Java 中多线程间的通信怎么实现?
        /**
         * 线程通信的方式：
         *      1.共享变量
         *          线程间通信可以通过发送信号，发送信号的一个简单方式是在共享对象的变量里设置信号值。线程 A 在一个
         *          同步块里设置 boolean 型成员变量 hasDataToProcess 为 true，线程 B 也在同步块里读取 hasDataToProcess
         *          这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了 set 和 get 方法:
         *      2.wait/notify 机制
         */

        // 14. 线程和进程的区别
        /**
         * 进程：具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位
         * 线程：是进程的一个实体，是 cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位。
         * 特点：线程的划分尺度小于进程，这使多线程程序拥有高并发性，进程在运行时各自内存单元相互独立，线程之间
         *      内存共享，这使多线程编程可以拥有更好的性能和用户体验
         * 注意：多线程编程对于其它程序是不友好的，占据大量 cpu 资源
         */

        // 15. 请说出同步线程及线程调度相关的方法？
        /**
         *      wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
         *      sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；
         *      notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，
         *              而是由 JVM 确定唤醒哪个线程，而且与优先级无关；
         *      notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁
         *              的线程才能进入就绪状态；
         *      注意：java 5 通过 Lock 接口提供了显示的锁机制，Lock 接口中定义了加锁（lock（）方法）和解锁（unLock（）
         *          方法），增强了多线程编程的灵活性及对线程的协调
         */

        // 16. 启动一个线程是调用 run()方法还是 start()方法？
        /**
         *      启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并
         * 执行，这并不意味着线程就会立即运行。
         *      run()方法是线程启动后要进行回调（callback）的方法。
         */





    }

}

package cn.com.bate5.javasehigh.c_designmode_garbagecollect;

public class B_GarbageCollect {

    // 9. JVM垃圾回收机制和常见算法
    /**
     *     理论上来讲Sun公司只定义了垃圾回收机制规则而不局限于其实现算法，因此不同厂商生产的虚拟机采用的算法也不尽相同。
     *     GC（Garbage Collector）在回收对象前首先必须发现那些无用的对象，如何去发现定位这些无用的对象？常用的搜索算法如下：
     *     1）引用计数器算法（废弃）
     *          引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，
     *       计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，是“垃圾”了。
     *          引用计数器实现简单，效率高；但是不能解决循环引用问问题（A对象引用B对象，B对象又引用A对象，但是
     *       A,B对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在JDK1.1之后，
     *       这个算法已经不再使用了。
     *     2）根搜索算法（使用）
     *          根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链
     *       （Reference Chain），当一个对象没有被GC Roots的引用链连接的时候，说明这个对象是不可用的。
     *          GC Roots对象包括：
     *              a) 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
     *              b) 方法区域中的类静态属性引用的对象。
     *              c) 方法区域中常量引用的对象。
     *              d) 本地方法栈中JNI（Native方法）的引用的对象。
     *
     *              通过上面的算法搜索到无用对象之后，就是回收过程，回收算法如下：
     *                  1）标记—清除算法（Mark-Sweep）（DVM使用的算法）
     *                         标记—清除算法包括两个阶段：“标记”和“清除”。在标记阶段，确定所有要回收的对象，并做标记。清除阶段
     *                      紧随标记阶段，将标记阶段确定不可用的对象清除。标记—清除算法是基础的收集算法，标记和清除阶段的效率不高，
     *                      而且清除后回产生大量的不连续空间，这样当程序需要分配大内存对象时，可能无法找到足够的连续空间。
     *                  2）复制算法（Copying）
     *                         复制算法是把内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，
     *                      然后把这块内存整个清理掉。复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率
     *                      不高。现在的JVM用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例
     *                      不是1:1(大概是8:1)。
     *                  3）标记—整理算法（Mark-Compact）
     *                          标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对
     *                      象往内存的一端移动，然后直接回收边界以外的内存。标记—整理算法提高了内存的利用率，并且它适合在收集对象
     *                      存活时间较长的老年代。
     *                  4）分代收集（Generational Collection）
     *                          分代收集是根据对象的存活时间把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃
     *                      圾回收算法。新生代采用复制算法，老年代采用标记—整理算法。垃圾算法的实现涉及大量的程序细节，而且不同的
     *                      虚拟机平台实现的方法也各不相同。
     *
     *
     */


    // 10. 谈谈JVM的内存结构和内存分配
    /**
     *      Java虚拟机将其管辖的内存大致分三个逻辑部分：方法区(Method Area)、Java栈和Java堆
     *
     *    a) Java内存模型
     *      1、方法区是静态分配的，编译器将变量绑定在某个存储位置上，而且这些绑定不会在运行时改变。
     *          常数池，源代码中的命名常量、String常量和static变量保存在方法区。
     *      2、Java Stack是一个逻辑概念，特点是后进先出。一个栈的空间可能是连续的，也可能是不连续的。
     *          最典型的Stack应用是方法的调用，Java虚拟机每调用一次方法就创建一个方法帧（frame），退出该
     *          方法则对应的 方法帧被弹出(pop)。栈中存储的数据也是运行时确定的。
     *      3、Java堆分配(heap allocation)意味着以随意的顺序，在运行时进行存储空间分配和收回的内存管理模型。
     *          堆中存储的数据常常是大小、数量和生命期在编译时无法确定的。Java对象的内存总是在heap中分配。
     *          我们每天都在写代码，每天都在使用JVM的内存。
     *    b) java内存分配
     *      1、基础数据类型直接在栈空间分配;
     *      2、方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收;
     *      3、引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量;
     *      4、方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完后从栈空间回收;
     *      5、局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收;
     *      6、方法调用时传入的实际参数，先在栈空间分配，在方法调用完成后从栈空间释放;
     *      7、字符串常量在 DATA 区域分配 ，this 在堆空间分配;
     *      8、数组既在栈空间分配数组名称， 又在堆空间分配数组实际的大小！
     *
     */


    // 11. Java 中引用类型都有哪些？（重要）
    /**
     *      Java 中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。
     *      强引用（StrongReference）
     *              这个就不多说，我们写代码天天在用的就是强引用。如果一个对象被被人拥有强引用，那么垃圾回收器绝不
     *          会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使使程序异常终止，也不会靠随意
     *          回收具有强引用的对象来解决内存不足问题。
     *              Java 的对象是位于 heap 中的，heap 中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到
     *          达对象。应用的强弱顺序是强、软、弱、和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。
     *          如下代码：
     *              String abc=new String("abc"); //1
     *              SoftReference<String> softRef=new SoftReference<String>(abc); //2
     *              WeakReference<String> weakRef = new WeakReference<String>(abc); //3
     *              abc=null; //4
     *              softRef.clear();//5
     *              第一行在 heap 堆中创建内容为“abc”的对象，并建立 abc 到该对象的强引用，该对象是强可及的。
     *              第二行和第三行分别建立对 heap 中对象的软引用和弱引用，此时 heap 中的 abc 对象已经有 3 个引用，显然此
     *          时 abc 对象仍是强可及的。
     *              第四行之后 heap 中对象不再是强可及的，变成软可及的。
     *              第五行执行之后变成弱可及的。
     *       软引用（SoftReference）
     *              如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会
     *          回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
     *              软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚
     *          拟机就会把这个软引用加入到与之关联的引用队列中。
     *              软引用是主要用于内存敏感的高速缓存。在 jvm 报告内存不足之前会清除所有的软引用，这样以来 gc 就有
     *          可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于 gc 的算法和 gc 运行
     *          时可用内存的大小。当 gc 决定要收集软引用时执行以下过程,以上面的 softRef 为例：
     *              1 首先将 softRef 的 referent（abc）设置为 null，不再引用 heap 中的 new String("abc")对象。
     *              2 将 heap 中的 new String("abc")对象设置为可结束的(finalizable)。
     *              3 当 heap 中的 new String("abc")对象的 finalize()方法被运行而且该对象占用的内存被释放， softRef
     *          被添加到它的 ReferenceQueue(如果有的话)中。
     *              注意:对 ReferenceQueue 软引用和弱引用可以有可无，但是虚引用必须有。
     *              被 Soft Reference 指到的对象，即使没有任何 Direct Reference，也不会被清除。一直要到 JVM 内存
     *          不足且没有 Direct Reference 时才会清除，SoftReference 是用来设计 object-cache 之用的。如此一来
     *          SoftReference 不但可以把对象 cache 起来，也不会造成内存不足的错误 （OutOfMemoryError）。
     *       弱引用（WeakReference）
     *              如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被 gc 扫描到了随时都会把它干
     *          掉。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖
     *          的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过
     *          由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
     *              弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚
     *          拟机就会把这个弱引用加入到与之关联的引用队列中。
     *       虚引用（PhantomReference）
     *              "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对
     *          象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃
     *          圾回收的活动。
     *              虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回
     *          收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联
     *          的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
     *          程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
     *              建立虚引用之后通过 get 方法返回结果始终为 null,通过源代码你会发现,虚引用通向会把引用的对象写进
     *          referent,只是 get 方法返回结果为 null。先看一下和 gc 交互的过程再说一下他的作用。
     *              1 不把 referent 设置为 null, 直接把 heap 中的 new String("abc")对象设置为可结束的(finalizable)。
     *              2 与软引用和弱引用不同, 先把 PhantomRefrence 对象添加到它的 ReferenceQueue 中.然后在释放虚可及的对象。
     *
     *
     *
     */

    // 12. heap 和 stack 有什么区别
    /**
     *      从以下几个方面阐述堆（heap）和栈（stack）的区别。
     *      1. 申请方式
     *          stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间
     *          heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于 Java 需要手动 new Object()的形式开辟
     *      2. 申请后系统的响应
     *          stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
     *          heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
     *               会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间
     *               分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空
     *               闲链表中。
     *      3. 申请大小的限制
     *          stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是
     *              系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果
     *              申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
     *          heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，
     *              自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，
     *              堆获得的空间比较灵活，也比较大。
     *      4. 申请效率的比较：
     *          stack：由系统自动分配，速度较快。但程序员是无法控制的。
     *          heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。
     *      5. heap 和 stack 中的存储内容
     *          stack：
     *                 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，
     *              然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量
     *              是不入栈的。
     *                 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下
     *              一条指令，程序由该点继续运行。
     *          heap：
     *                 一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
     *      6. 数据结构层面的区别
     *              还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一
     *          种数据结构，第 1 个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。
     *          虽然堆栈，堆栈的说法是连起来叫，但是他们还是有很大区别的，连着叫只是由于历史的原因。
     */

    // 13. 解释内存中的栈 (stack) 、堆 (heap) 和方法区 (method area) 的用法

}



















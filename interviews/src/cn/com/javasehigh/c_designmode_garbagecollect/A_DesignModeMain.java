package cn.com.javasehigh.c_designmode_garbagecollect;

public class A_DesignModeMain {
    // 1. 你所知道的设计模式有哪些
    /**
     *      Java中一般认为有23种设计模式，我们不需要所有的都会，但是其中常用的几种设计模式应该去掌握。
     *      总体来说设计模式分为三大类：
     *          创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
     *          结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
     *          行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、
     *                            备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
     */

    // 2. 单例设计模式
    /**
     *      最好理解的一种设计模式，分为懒汉式和饿汉式。
     */

    // 3. 工厂设计模式
    /**
     *   工厂模式分为工厂方法模式和抽象工厂模式。
     *
     *      工厂方法模式 :工厂方法模式分为三种：
     *          普通工厂模式: 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建.
     *          多个工厂方法模式: 是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能
     *                          正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。
     *          静态工厂方法模式: 将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
     *      抽象工厂模式:
     *              工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修
     *          改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂
     *          类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
     */

    // 4. 建造者模式（Builder）
    /**
     *         工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，
     *      所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的 Test 结合起来得到的.
     */

    // 5. 适配器设计模式
    /**
     *         适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容
     *      性问题。
     *          主要分为三类：
     *              类的适配器模式、
     *              对象的适配器模式、
     *              接口的适配器模式。
     *
     *              接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接
     *          口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个
     *          问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原
     *          始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。
     */

    // 6. 装饰模式（Decorator）
    /**
     *         顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个
     *      接口，装饰对象持有被装饰对象的实例。
     */

    // 7. 策略模式（strategy）
    /**
     *          策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法
     *      的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，
     *      属于辅助类），提供辅助函数。策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种
     *      算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。
     */

    // 8. 观察者模式（Observer）
    /**
     *      观察者模式很好理解，类似于邮件订阅和 RSS 订阅，当我们浏览一些博客或 wiki 时，经常会看到 RSS 图标，就
     *   这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其
     *   它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。
     */














}



















